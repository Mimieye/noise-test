{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/_js/helper.js","webpack:///./src/_js/setting.js","webpack:///./src/_js/index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","THREE","replaceThreeChunkFn","a","b","ShaderChunk","shaderParse","glsl","replace","rand","min","max","Math","random","mainLight","x","y","z","g","ambientLight","_js_THREE","gui","GUI","OrbitControls","SimplexNoise","container","document","getElementById","scene","camera","renderer","controls","flowField","vertexOff","simplex","controllerSetting","amount","size","gridWidth","gridHeight","gridLength","numOnWidth","numOnHeight","numOnLength","unitWitdh","unitHeight","unitLength","pointSize","noiseScale","noiseOffsetX","noiseOffsetY","noiseOffsetZ","increment","frequency","colorR","colorG","colorB","onWindowResize","aspect","innerWidth","innerHeight","updateProjectionMatrix","setSize","animate","requestAnimationFrame","render","lookAt","position","update","fposition","geometry","attributes","array","fcolor","color","fsize","xOff","yOff","zOff","noise","noise4D","index","pi","noiseDir","Vector3","cos","PI","sin","fx","normalize","fy","fz","needsUpdate","Scene","PerspectiveCamera","set","WebGLRenderer","canvas","antialias","setClearColor","setPixelRatio","devicePixelRatio","shadowMap","enabled","type","PCFSoftShadowMap","axes","AxesHelper","gridXZ","GridHelper","domElement","add","folder2","addFolder","folder3","folder4","open","settingGUI","shaderMaterial","ShaderMaterial","uniforms","UniformsUtils","merge","UniformsLib","shadowmap","lights","lightPosition","lightColor","lightStrength","ambientLight_strength","ambientLight_color","vertexShader","textContent","fragmentShader","blending","NoBlending","flowFieldPosition","Float32Array","flowFieldColors","flowFieldSizs","flowFieldGeometry","BufferGeometry","addAttribute","Float32BufferAttribute","Points","planeGeometry","PlaneBufferGeometry","planeMaterial","MeshPhongMaterial","plane","Mesh","rotation","receiveShadow","ambient","AmbientLight","Color","addEventListener","init"],"mappings":"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","file":"assets/js/app.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([5,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","const THREE = require('three');\r\n\r\nconst replaceThreeChunkFn = (a, b) => THREE.ShaderChunk[b] + \"\\n\";\r\nexport const shaderParse = glsl => glsl.replace(/\\/\\/\\s?chunk\\(\\s?(\\w+)\\s?\\);/g, replaceThreeChunkFn);\r\nexport const rand = (min, max) => min + Math.random() * (max - min);\r\n","\r\nexport const mainLight = {\r\n    position: {\r\n        x: 0,\r\n        y: 100,\r\n        z: 100\r\n    },\r\n    strength: 0.8,\r\n    color: {\r\n        r: 1.0,\r\n        g: 1.0,\r\n        b: 1.0\r\n    }\r\n};\r\nexport const ambientLight = {\r\n    strength: 0.5,\r\n    color: {\r\n        r: 1.0,\r\n        g: 1.0,\r\n        b: 1.0\r\n    }\r\n};\r\n// export const particles = {\r\n    // totalNum: 5000,\r\n    // size: 8,\r\n    // color: {\r\n    //     r: 0.832,\r\n    //     g: 0.821,\r\n    //     b: 0.855\r\n    // }\r\n// };\r\n\r\n// export const gridSize = {\r\n//     maxWidth: 10,\r\n//     maxHeight: 10,\r\n//     maxLength: 10,\r\n//     size: 10,\r\n//     pointSize: 2\r\n// }\r\n// export const noiseOffset = {\r\n//     x: 0,\r\n//     y: 0,\r\n//     z: 0\r\n// }\r\n\r\n// export const increment = 10;\r\n// export const noiseScale = 100;","import { rand, shaderParse } from \"./helper.js\";\r\nimport { mainLight, ambientLight } from \"./setting.js\";\r\n\r\nconst THREE = require('three');\r\nconst dat = require('dat.gui');\r\nconst gui = new dat.GUI();\r\nconst OrbitControls = require('three-orbitcontrols');\r\nconst SimplexNoise = require('simplex-noise');\r\n\r\nconst container = document.getElementById(\"canvas\");\r\n\r\nlet scene, camera, renderer;\r\nlet controls;\r\nlet points, flowField;\r\n\r\nlet vertexOff = 0;\r\nlet simplex = new SimplexNoise(1337);\r\n\r\n// if (process.env.NODE_ENV !== 'production') {\r\n//     console.log('Looks like we are in development mode!');\r\n// }\r\n\r\nlet controllerSetting = {\r\n    'amount': 5000,\r\n    'size': 8,\r\n\r\n    'gridWidth': 100,\r\n    'gridHeight': 100,\r\n    'gridLength': 100,\r\n    'numOnWidth': 40,\r\n    'numOnHeight': 40,\r\n    'numOnLength': 40,\r\n    'unitWitdh': 1,\r\n    'unitHeight': 1,\r\n    'unitLength': 1,\r\n    'pointSize': 1,\r\n\r\n    'noiseScale': 50,\r\n    'noiseOffsetX': 0,\r\n    'noiseOffsetY': 0,\r\n    'noiseOffsetZ': 0,\r\n    'increment': 1.5,\r\n    'frequency': 0,\r\n\r\n    'colorR': rand(0, 255),\r\n    'colorG': rand(0, 255),\r\n    'colorB': rand(0, 255),\r\n}\r\n\r\nlet settingGUI = () => {\r\n    // let folder1 = gui.addFolder('Particle');\r\n    let folder2 = gui.addFolder('Grid');\r\n    let folder3 = gui.addFolder('Noise');\r\n    let folder4 = gui.addFolder('Color');\r\n\r\n    // folder1.add(controllerSetting, 'amount');\r\n    // folder1.add(controllerSetting, 'size');\r\n\r\n    folder2.add(controllerSetting, 'numOnWidth', 1, controllerSetting.gridWidth, 1);\r\n    folder2.add(controllerSetting, 'numOnHeight', 1, controllerSetting.gridHeight, 1);\r\n    folder2.add(controllerSetting, 'numOnLength', 1, controllerSetting.gridLength, 1);\r\n    folder2.add(controllerSetting, 'unitWitdh', 1, controllerSetting.gridLength, 1);\r\n    folder2.add(controllerSetting, 'unitHeight', 1, controllerSetting.gridLength, 1);\r\n    folder2.add(controllerSetting, 'unitLength', 1, controllerSetting.gridLength, 1);\r\n    folder2.add(controllerSetting, 'pointSize', 0, 5);\r\n\r\n    folder3.add(controllerSetting, 'noiseScale', 1, 500);\r\n    folder3.add(controllerSetting, 'noiseOffsetX', 0, 500);\r\n    folder3.add(controllerSetting, 'noiseOffsetY', 0, 500);\r\n    folder3.add(controllerSetting, 'noiseOffsetZ', 0, 500);\r\n    folder3.add(controllerSetting, 'increment', 1, 10);\r\n    folder3.add(controllerSetting, 'frequency', 0, 10000, 1);\r\n\r\n    folder4.add(controllerSetting, 'colorR', 0, 255, 1);\r\n    folder4.add(controllerSetting, 'colorG', 0, 255, 1);\r\n    folder4.add(controllerSetting, 'colorB', 0, 255, 1);\r\n\r\n\r\n    // folder1.open();\r\n\tfolder2.open();\r\n\tfolder3.open();\r\n\tfolder4.open();\r\n}\r\n\r\n\r\n\r\nlet init = () => {\r\n    scene = new THREE.Scene();\r\n\r\n    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 10000);\r\n    camera.position.set(184 * 0.4, 128 * 0.4, 162 * 0.4);\r\n\r\n    renderer = new THREE.WebGLRenderer({canvas: container, antialias: true});\r\n    renderer.setClearColor(0x333333);\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    renderer.shadowMap.enabled = true;\r\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n\r\n\r\n    const axes = new THREE.AxesHelper(500);\r\n    const gridXZ = new THREE.GridHelper(5000 , 100, 0xFFFFFF);\r\n    controls = new OrbitControls(camera, renderer.domElement);\r\n    scene.add(axes);\r\n    scene.add(gridXZ);\r\n\r\n    settingGUI();\r\n\r\n\r\n    let shaderMaterial = new THREE.ShaderMaterial({\r\n        uniforms: THREE.UniformsUtils.merge([\r\n            THREE.UniformsLib.shadowmap,\r\n            THREE.UniformsLib.lights,\r\n            {\r\n                // u_size: {\r\n                //     type: \"f\",\r\n                //     value: particles.size\r\n                // },\r\n                lightPosition: {\r\n                    type: \"v3\",\r\n                    value: new THREE.Vector3(mainLight.position.x, mainLight.position.y, mainLight.position.z)\r\n                },\r\n                lightColor: {\r\n                    type: \"v3\",\r\n                    value: new THREE.Vector3(mainLight.color.r, mainLight.color.g, mainLight.color.b)\r\n                },\r\n                lightStrength: {\r\n                    type: \"f\",\r\n                    value: mainLight.strength\r\n                },\r\n                ambientLight_strength: {\r\n                    type: \"f\",\r\n                    value: ambientLight.strength\r\n                },\r\n                ambientLight_color: {\r\n                    type: \"v3\",\r\n                    value: new THREE.Vector3(ambientLight.color.r, ambientLight.color.g, ambientLight.color.b)\r\n                },\r\n            }\r\n        ]),\r\n        vertexShader: shaderParse(document.getElementById(\"vertexShader\").textContent),\r\n        fragmentShader: shaderParse(document.getElementById(\"fragmentShader\").textContent),\r\n        lights: true,\r\n        blending: THREE.NoBlending\r\n    });\r\n\r\n\r\n    let flowFieldPosition = new Float32Array(controllerSetting.gridWidth * controllerSetting.gridHeight * controllerSetting.gridLength * 3);\r\n    let flowFieldColors = new Float32Array(controllerSetting.gridWidth * controllerSetting.gridHeight * controllerSetting.gridLength * 3);\r\n    let flowFieldSizs = new Float32Array(controllerSetting.gridWidth * controllerSetting.gridHeight * controllerSetting.gridLength);\r\n    let flowFieldGeometry = new THREE.BufferGeometry();\r\n    flowFieldGeometry.addAttribute('position', new THREE.Float32BufferAttribute(flowFieldPosition, 3));\r\n    flowFieldGeometry.addAttribute('color', new THREE.Float32BufferAttribute(flowFieldColors, 3));\r\n    flowFieldGeometry.addAttribute('size', new THREE.Float32BufferAttribute(flowFieldSizs, 1));\r\n\r\n\r\n\r\n\r\n    flowField = new THREE.Points(flowFieldGeometry, shaderMaterial);\r\n    // flowField.customDepthMaterial = new THREE.ShaderMaterial({\r\n    //     uniforms: shaderMaterial.uniforms,\r\n    //     vertexShader: document.getElementById(\"depthVertexShader\").textContent,\r\n    //     fragmentShader: document.getElementById(\"depthFragmentShader\").textContent,\r\n    //     depthTest: true\r\n    // });\r\n    // flowField.castShadow = true;\r\n    // flowField.receiveShadow = true;\r\n    scene.add(flowField);\r\n\r\n\r\n    let planeGeometry = new THREE.PlaneBufferGeometry(5000, 5000, 32, 32);\r\n    let planeMaterial = new THREE.MeshPhongMaterial();\r\n    let plane = new THREE.Mesh(planeGeometry, planeMaterial);\r\n    plane.rotation.x = -90 * (Math.PI / 180);\r\n    plane.receiveShadow = true;\r\n    plane.position.y = -200;\r\n    // scene.add(plane);\r\n\r\n\r\n    let ambient = new THREE.AmbientLight(new THREE.Color(ambientLight.color.r, ambientLight.color.g, ambientLight.color.b), ambientLight.strength);\r\n    scene.add(ambient);\r\n\r\n    // let dirLight = new THREE.DirectionalLight(\r\n    //     new THREE.Color(mainLight.color.r, mainLight.color.g, mainLight.color.b),\r\n    //     mainLight.strength\r\n    // );\r\n    // dirLight.position.set(mainLight.position.x, mainLight.position.y, mainLight.position.z);\r\n    // dirLight.castShadow = true;\r\n    // dirLight.shadow.camera.near = 0.5;\r\n    // dirLight.shadow.camera.far = 4000;\r\n    // dirLight.shadow.camera.right = 800;\r\n    // dirLight.shadow.camera.left = -800;\r\n    // dirLight.shadow.camera.top = 800;\r\n    // dirLight.shadow.camera.bottom = -800;\r\n    // dirLight.shadow.mapSize.width = 1024 * 2;\r\n    // dirLight.shadow.mapSize.height = 1024 * 2;\r\n    // scene.add(dirLight);\r\n    // scene.add(new THREE.CameraHelper(dirLight.shadow.camera));\r\n\r\n\r\n    window.addEventListener(\"resize\", onWindowResize, false);\r\n}\r\n\r\nlet onWindowResize = () => {\r\n    camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.updateProjectionMatrix();\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n}\r\n\r\nlet animate = () => {\r\n    requestAnimationFrame(animate);\r\n\r\n    render();\r\n}\r\nlet render = () => {\r\n    camera.lookAt(scene.position);\r\n    controls.update();\r\n\r\n    let fposition = flowField.geometry.attributes.position.array;\r\n    let fcolor = flowField.geometry.attributes.color.array;\r\n    let fsize = flowField.geometry.attributes.size.array;\r\n    let {\r\n        numOnWidth,\r\n        numOnHeight,\r\n        numOnLength,\r\n        unitWitdh,\r\n        unitHeight,\r\n        unitLength,\r\n\r\n        noiseScale,\r\n        noiseOffsetX,\r\n        noiseOffsetY,\r\n        noiseOffsetZ,\r\n        increment,\r\n        frequency,\r\n        pointSize,\r\n\r\n        colorR,\r\n        colorG,\r\n        colorB\r\n    } = controllerSetting;\r\n\r\n    for (let i = 0; i < fsize.length; i++) {\r\n        fsize[i] = 0;\r\n    }\r\n    for (let i = 0; i < fposition.length; i++) {\r\n        fposition[i] = 0;\r\n    }\r\n\r\n\r\n    let xOff = 0;\r\n    for (let x = 0; x < numOnWidth; x++) {\r\n        let yOff = 0;\r\n        for (let y = 0; y < numOnHeight; y++) {\r\n            let zOff = 0;\r\n            for (let z = 0; z < numOnLength; z++) {\r\n                let noise = simplex.noise4D((xOff + noiseOffsetX) / noiseScale, (yOff + noiseOffsetY) / noiseScale, (zOff + noiseOffsetZ) / noiseScale, vertexOff);\r\n                let index = z + (y + x * numOnHeight) * numOnLength;\r\n                let pi = index * 3;\r\n                let noiseDir = new THREE.Vector3(\r\n                    Math.cos(noise * 2 * Math.PI),\r\n                    Math.sin(noise * 2 * Math.PI),\r\n                    Math.cos(noise * 2 * Math.PI)\r\n                );\r\n                let fx = noiseDir.normalize().x,\r\n                    fy = noiseDir.normalize().y,\r\n                    fz = noiseDir.normalize().z;\r\n\r\n                fposition[pi + 0] = x * unitWitdh + fx;\r\n                fposition[pi + 1] = y * unitHeight + fy;\r\n                fposition[pi + 2] = z * unitLength + fz;\r\n\r\n                fcolor[pi + 0] = colorR / 255 * (fx + 1);\r\n                fcolor[pi + 1] = colorG / 255 * (fy + 1);\r\n                fcolor[pi + 2] = colorB / 255 * (fz + 1);\r\n\r\n                fsize[index] = pointSize;\r\n\r\n                zOff += increment;\r\n            }\r\n            yOff += increment;\r\n        }\r\n        xOff += increment;\r\n\r\n        vertexOff += frequency / 1000000;\r\n    }\r\n\r\n    flowField.geometry.attributes.position.needsUpdate = true;\r\n    flowField.geometry.attributes.color.needsUpdate = true;\r\n    flowField.geometry.attributes.size.needsUpdate = true;\r\n    renderer.render(scene, camera);\r\n}\r\n\r\ninit();\r\nanimate();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// let fcolor = flowField.geometry.attributes.color.array;\r\n// let nx = Math.ceil(controllerSetting.gridWidth / (cols - 1)) - 1;\r\n// let ny = Math.ceil(controllerSetting.gridHeight / (rows - 1)) - 1;\r\n// let nz = Math.ceil(controllerSetting.gridLength / (depth - 1)) - 1;\r\n\r\n// for (let i = 0; i < fcolor.length; i++) {\r\n//     fcolor[i] = 1;\r\n// }\r\n// for (let x = 0; x < controllerSetting.gridWidth; x += nx) {\r\n//     for (let y = 0; y < controllerSetting.gridHeight; y += ny) {\r\n//         for (let z = 0; z < controllerSetting.gridLength; z += nz) {\r\n//             let index = z + (y + x * controllerSetting.gridHeight) * controllerSetting.gridLength;\r\n//             fcolor[index * 3 + 0] = 1;\r\n//             fcolor[index * 3 + 1] = 0;\r\n//             fcolor[index * 3 + 2] = 0;\r\n//         }\r\n//     }\r\n// }"],"sourceRoot":""}